defmodule VsmPhoenix.Resilience.IntegrationTest do
  @moduledoc """
  Test module to verify resilience patterns work with all refactored architectures.
  
  This ensures:
  - Circuit breakers work with CRDT Context Store
  - Bulkheads integrate with Cortical Attention Engine  
  - Retry patterns use aMCP secure routing
  - All patterns emit telemetry signals
  """
  
  use VsmPhoenix.Resilience.GodObjectBehavior,
    module_type: :integration_test,
    circuits: [:crdt_ops, :attention_scoring, :secure_routing, :telemetry_sampling],
    bulkheads: [
      crdt_sync: [max_concurrent: 5, max_waiting: 20],
      attention_ops: [max_concurrent: 3, max_waiting: 10],
      amcp_routing: [max_concurrent: 10, max_waiting: 30]
    ],
    error_context: :resilience_integration_test
  
  require Logger
  
  # Import refactored components
  alias VsmPhoenix.CRDT.ContextStore
  alias VsmPhoenix.System2.CorticalAttentionEngine
  alias VsmPhoenix.AMQP.SecureContextRouter
  alias VsmPhoenix.Telemetry.RefactoredAnalogArchitect
  alias VsmPhoenix.Resilience.RefactoredIntegration
  
  @doc """
  Test CRDT operations with circuit breaker protection.
  """
  def test_crdt_with_circuit_breaker do
    Logger.info("🧪 Testing CRDT with circuit breaker...")
    
    with_circuit_breaker :crdt_ops do
      # Test various CRDT operations
      {:ok, _} = ContextStore.increment_counter("test_counter", 1)
      {:ok, _} = ContextStore.add_to_set("test_set", "element1")
      {:ok, _} = ContextStore.update_lww_set("test_lww", node(), %{test: true})
      
      Logger.info("✅ CRDT operations successful with circuit breaker")
      :ok
    end
  end
  
  @doc """
  Test Cortical Attention Engine with bulkhead isolation.
  """
  def test_attention_with_bulkhead do
    Logger.info("🧪 Testing Cortical Attention with bulkhead...")
    
    with_bulkhead :attention_ops do
      # Score multiple messages
      messages = [
        %{type: :test, priority: :high, content: "Critical test message"},
        %{type: :test, priority: :normal, content: "Normal test message"},
        %{type: :test, priority: :low, content: "Low priority message"}
      ]
      
      Enum.each(messages, fn msg ->
        {:ok, score, _} = CorticalAttentionEngine.score_attention(msg, %{test: true})
        Logger.info("Message scored: #{score}")
      end)
      
      Logger.info("✅ Attention scoring successful with bulkhead")
      :ok
    end
  end
  
  @doc """
  Test secure AMQP routing with retry patterns.
  """
  def test_secure_routing_with_retry do
    Logger.info("🧪 Testing secure routing with retry...")
    
    with_error_handling :secure_routing, %{test: true}, [max_attempts: 3] do
      # Send secure command
      SecureContextRouter.send_secure_command(
        "test_agent",
        %{type: :test_command, data: "test"},
        %{encrypted: true}
      )
      
      Logger.info("✅ Secure routing successful with retry")
      :ok
    end
  end
  
  @doc """
  Test telemetry integration with all resilience patterns.
  """
  def test_telemetry_with_full_resilience do
    Logger.info("🧪 Testing telemetry with full resilience...")
    
    with_full_resilience(:telemetry_sampling, :crdt_sync) do
      # Register test signal
      RefactoredAnalogArchitect.register_signal("resilience_test", %{
        signal_type: :gauge,
        sampling_rate: :high
      })
      
      # Sample values
      for i <- 1..10 do
        RefactoredAnalogArchitect.sample_signal("resilience_test", i * 10, %{
          test_iteration: i
        })
      end
      
      # Analyze
      {:ok, analysis} = RefactoredAnalogArchitect.analyze_waveform("resilience_test", :statistical)
      
      Logger.info("✅ Telemetry analysis: #{inspect(analysis)}")
      :ok
    end
  end
  
  @doc """
  Test integrated resilience with CRDT-backed circuit breakers.
  """
  def test_crdt_circuit_integration do
    Logger.info("🧪 Testing CRDT-backed circuit breaker...")
    
    RefactoredIntegration.with_crdt_circuit_breaker(
      "test_circuit",
      fn ->
        # Simulate some work
        Process.sleep(100)
        {:ok, "Circuit test completed"}
      end,
      [fallback: fn -> {:ok, "Fallback activated"} end]
    )
  end
  
  @doc """
  Test attention-priority execution.
  """
  def test_attention_priority_execution do
    Logger.info("🧪 Testing attention-priority execution...")
    
    RefactoredIntegration.with_attention_priority(
      fn ->
        # High-priority operation
        Process.sleep(50)
        {:ok, "High priority operation completed"}
      end,
      %{importance: :critical, source: :test},
      [priority: :high]
    )
  end
  
  @doc """
  Test telemetry monitoring wrapper.
  """
  def test_telemetry_monitoring do
    Logger.info("🧪 Testing telemetry monitoring...")
    
    RefactoredIntegration.with_telemetry_monitoring(
      "test_operation",
      fn ->
        # Monitored operation
        Process.sleep(200)
        {:ok, "Monitored operation completed"}
      end
    )
  end
  
  @doc """
  Run all integration tests.
  """
  def run_all_tests do
    Logger.info("🚀 Starting resilience integration tests...")
    
    tests = [
      {:crdt_circuit_breaker, &test_crdt_with_circuit_breaker/0},
      {:attention_bulkhead, &test_attention_with_bulkhead/0},
      {:secure_routing_retry, &test_secure_routing_with_retry/0},
      {:telemetry_full_resilience, &test_telemetry_with_full_resilience/0},
      {:crdt_circuit_integration, &test_crdt_circuit_integration/0},
      {:attention_priority, &test_attention_priority_execution/0},
      {:telemetry_monitoring, &test_telemetry_monitoring/0}
    ]
    
    results = Enum.map(tests, fn {name, test_fn} ->
      try do
        test_fn.()
        {name, :passed}
      rescue
        e ->
          Logger.error("Test #{name} failed: #{inspect(e)}")
          {name, {:failed, e}}
      end
    end)
    
    passed = Enum.count(results, fn {_, status} -> status == :passed end)
    total = length(results)
    
    Logger.info("📊 Test Results: #{passed}/#{total} passed")
    
    if passed == total do
      Logger.info("✅ All resilience integration tests passed!")
      {:ok, results}
    else
      Logger.error("❌ Some tests failed")
      {:error, results}
    end
  end
  
  @doc """
  Initialize test module with all required circuit breakers and bulkheads.
  """
  def init do
    Logger.info("Initializing resilience integration test module...")
    
    # Initialize circuit breakers
    init_circuit_breakers()
    
    # Initialize bulkhead pools  
    init_bulkhead_pools()
    
    # Initialize refactored integration
    RefactoredIntegration.initialize_resilience_integrations()
    
    Logger.info("✅ Integration test module initialized")
    :ok
  end
end